---
import { musicList } from "@/data/music";
// 默认播放第一首
const initialPlaylist = JSON.stringify(musicList);
const initialSong = musicList[0] || {};
---
<div transition:persist="ryuchan-global-audio-wrapper">
    <!-- 全局音频元素，持久化 -->
    <audio id="global-audio-player"></audio>

    <!-- 迷你播放器容器，只在非音乐页面显示 -->
    <div id="mini-player-container" class="fixed bottom-8 left-8 z-[999] flex flex-col items-start gap-4 pointer-events-none opacity-0 transition-opacity duration-300">
        <!-- 展开的卡片 -->
        <div id="mini-player-card" class="bg-neu-base/90 dark:bg-[#1a1a1a]/90 backdrop-blur-md p-4 rounded-3xl shadow-neu-out border border-white/20 dark:border-white/10 w-64 translate-y-4 opacity-0 scale-95 transition-all duration-300 origin-bottom-left pointer-events-auto">
            <div class="flex gap-4">
                <div class="w-16 h-16 rounded-xl overflow-hidden shadow-md shrink-0">
                    <img id="mini-cover" src={initialSong.cover || "/favicon.svg"} class="w-full h-full object-cover" alt="cover"/>
                </div>
                <div class="flex flex-col justify-center min-w-0 flex-1">
                    <h3 id="mini-title" class="font-bold text-neu-text text-sm truncate">{initialSong.title || "RyuChan"}</h3>
                    <p id="mini-artist" class="text-xs text-neu-text-muted truncate mt-1">{initialSong.artist || "Music"}</p>
                </div>
            </div>
            <div class="flex justify-between items-center mt-4 px-4">
                <button id="mini-prev" class="text-neu-text-muted hover:text-neu-text transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" x2="5" y1="19" y2="5"/></svg>
                </button>
                <button id="mini-play" class="w-14 h-14 rounded-full bg-neu-btn-bg text-neu-btn-text shadow-neu-out flex items-center justify-center hover:scale-105 transition-transform">
                    <svg id="mini-icon-play" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1 fill-current"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <svg id="mini-icon-pause" class="hidden fill-current" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                </button>
                <button id="mini-next" class="text-neu-text-muted hover:text-neu-text transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/></svg>
                </button>
            </div>
        </div>

        <!-- 悬浮圆形按钮 -->
        <button id="mini-fab" class="w-16 h-16 rounded-full bg-neu-base/90 dark:bg-[#1a1a1a]/90 backdrop-blur-md shadow-neu-out border border-white/20 dark:border-white/10 flex items-center justify-center relative overflow-hidden group pointer-events-auto transition-transform hover:scale-105 active:scale-95">
            <div class="absolute inset-0 rounded-full animate-spin-slow" id="mini-fab-spin" style="animation-play-state: paused;">
                <img id="mini-fab-cover" src={initialSong.cover || "/favicon.svg"} class="w-full h-full object-cover opacity-60" alt="fab-cover"/>
            </div>
            <!-- Center Icon -->
            <div class="relative z-10 w-9 h-9 rounded-full bg-black/20 backdrop-blur-sm flex items-center justify-center text-white">
                <div class="w-3.5 h-3.5 flex gap-0.5 items-end justify-center group-hover:hidden" id="mini-fab-visualizer">
                    <div class="w-0.5 bg-white h-1.5 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-3 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-2 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-2.5 rounded-full transition-all duration-300"></div>
                </div>
                <!-- Play/Pause Icons (Shown on Hover) -->
                <div id="mini-fab-controls" class="hidden group-hover:flex items-center justify-center w-full h-full">
                    <svg id="mini-fab-icon-play" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 fill-current ml-0.5"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <svg id="mini-fab-icon-pause" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 fill-current hidden"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                </div>
            </div>
        </button>
    </div>
</div>

<script define:vars={{ initialPlaylist }}>
    class GlobalMusicPlayer {
        constructor() {
            // First time init: assume elements are present
            this.playlist = JSON.parse(initialPlaylist);
            this.currentIndex = 0;
            this.isPlaying = false;
            this.isShuffle = false;
            // 'all' = Loop All (Sequential), 'one' = Loop One, 'off' = No Loop (Stop at end)
            this.repeatMode = 'all'; 
            this.lyrics = [];
            this.lrcUrl = "";
            this.lastActiveIndex = -1;
            this.isMiniOpen = false;
            this.hasBoundDocumentClick = false;
            this.closeTimer = null;
            this.isDraggingProgress = false;
            this.isDraggingVolume = false;

            // Initial binding
            this.handlePageLoad();

            // Load initial song if needed
            if (this.playlist.length > 0 && this.audio && !this.audio.src) {
               this.loadSong(0, false);
            }
            
            // Listen for future navigations
            document.addEventListener('astro:page-load', () => this.handlePageLoad());
        }

        handlePageLoad() {
            // Re-acquire all DOM references to handle persistence failures or DOM updates
            this.bindGlobalAudioEvents();
            this.bindMiniPlayerEvents();
            
            // Check for Main Player widget
            this.container = document.querySelector('.music-player-widget');
            if (this.container) {
                // Bind Main Player UI
                this.playBtn = document.getElementById('play-btn');
                this.prevBtn = document.getElementById('prev-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.shuffleBtn = document.getElementById('shuffle-btn');
                this.repeatBtn = document.getElementById('repeat-btn');
                this.iconPlay = document.getElementById('icon-play');
                this.iconPause = document.getElementById('icon-pause');
                this.recordOuter = document.getElementById('record-outer');
                this.recordInner = document.getElementById('record-inner');
                this.needle = document.getElementById('player-needle');
                this.statusDot = document.getElementById('player-status-dot');
                this.statusText = document.getElementById('player-status-text');
                this.currentTimeEl = document.getElementById('current-time');
                this.totalTimeEl = document.getElementById('total-time');
                this.progressBar = document.getElementById('progress-bar');
                this.progressContainer = document.getElementById('progress-container');
                this.lyricsContainer = document.getElementById('lyrics-container');
                this.volumeControl = document.getElementById('volume-control');
                this.volumeBar = document.getElementById('volume-bar');
                this.btnPlaylist = document.getElementById('btn-show-playlist');
                this.btnLyrics = document.getElementById('btn-show-lyrics');
                this.playlistContainer = document.getElementById('playlist-container');
                this.playerTitle = document.getElementById('player-title');
                this.playerArtist = document.getElementById('player-artist');
                this.bgCover = document.getElementById('player-bg-cover');
                this.playerCover = document.getElementById('player-cover');
                
                this.bindUIEvents();
                // If we have lyrics loaded in memory, render them
                if (this.lyrics.length > 0 && this.lyricsContainer) {
                     this.renderLyrics();
                     this.syncLyrics(this.audio ? this.audio.currentTime : 0);
                } else if(this.lrcUrl) {
                    this.loadLyrics();
                }
                
                this.updatePlaylistDurations();
                this.bindPlaylistEvents();
            }

            // Sync playback status with audio element
            if (this.audio && !this.audio.paused) {
                 this.isPlaying = true;
            }

            // Update UI State (syncs both Mini and Main players)
            this.updateUI();

            // Handle Mini Player Visibility
            const path = window.location.pathname;
            const isMusicPage = path.includes('/music');
            
            if (this.miniContainer) {
                if (isMusicPage) {
                    this.miniContainer.classList.add('opacity-0', 'hidden');
                    this.miniContainer.classList.remove('opacity-100');
                    this.closeMiniPlayer();
                } else {
                    this.miniContainer.classList.remove('opacity-0', 'hidden');
                    this.miniContainer.classList.add('opacity-100');
                }
            }
        }

        bindGlobalAudioEvents() {
             this.audio = document.getElementById('global-audio-player');
             if(this.audio && !this.audio.dataset.hasGlobalEvents) {
                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('ended', () => this.nextSong(true));
                this.audio.addEventListener('play', () => { this.isPlaying = true; this.updateUI(); });
                this.audio.addEventListener('pause', () => { this.isPlaying = false; this.updateUI(); });
                this.audio.addEventListener('error', (e) => console.error("Audio error", e));
                this.audio.dataset.hasGlobalEvents = "true";
             }
             
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => this.togglePlay());
                navigator.mediaSession.setActionHandler('pause', () => this.togglePlay());
                navigator.mediaSession.setActionHandler('previoustrack', () => this.prevSong());
                navigator.mediaSession.setActionHandler('nexttrack', () => this.nextSong());
            }
        }

        bindMiniPlayerEvents() {
            // Always query fresh elements
            this.miniContainer = document.getElementById('mini-player-container');
            this.miniCard = document.getElementById('mini-player-card');
            this.miniFab = document.getElementById('mini-fab');
            this.miniPlayBtn = document.getElementById('mini-play');
            this.miniPrevBtn = document.getElementById('mini-prev');
            this.miniNextBtn = document.getElementById('mini-next');
            
            this.miniCover = document.getElementById('mini-cover');
            this.miniFabCover = document.getElementById('mini-fab-cover');
            this.miniTitle = document.getElementById('mini-title');
            this.miniArtist = document.getElementById('mini-artist');
            this.miniIconPlay = document.getElementById('mini-icon-play');
            this.miniIconPause = document.getElementById('mini-icon-pause');
            this.miniFabSpin = document.getElementById('mini-fab-spin');
            this.miniFabIconPlay = document.getElementById('mini-fab-icon-play');
            this.miniFabIconPause = document.getElementById('mini-fab-icon-pause');
            this.visualizerBars = document.querySelectorAll('#mini-fab-visualizer div');

            // Bind events only if not already bound on THIS specific element instance
            if(this.miniFab && !this.miniFab.dataset.bound) {
                this.miniFab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.togglePlay();
                });
                this.miniFab.addEventListener('mouseenter', () => this.openMiniPlayer());
                this.miniFab.addEventListener('mouseleave', () => this.scheduleCloseMiniPlayer());
                this.miniFab.dataset.bound = "true";
            }
            
            if(this.miniCard && !this.miniCard.dataset.bound) {
                this.miniCard.addEventListener('mouseenter', () => this.openMiniPlayer());
                this.miniCard.addEventListener('mouseleave', () => this.scheduleCloseMiniPlayer());
                this.miniCard.dataset.bound = "true";
            }
            
            // Remove old document logic for clicking outside since we are using hover now
            /* if (!this.hasBoundDocumentClick) { ... } */

            if(this.miniPlayBtn && !this.miniPlayBtn.dataset.bound) {
                this.miniPlayBtn.addEventListener('click', () => this.togglePlay());
                this.miniPlayBtn.dataset.bound = "true";
            }
            if(this.miniPrevBtn && !this.miniPrevBtn.dataset.bound) {
                this.miniPrevBtn.addEventListener('click', () => this.prevSong());
                this.miniPrevBtn.dataset.bound = "true";
            }
            if(this.miniNextBtn && !this.miniNextBtn.dataset.bound) {
                this.miniNextBtn.addEventListener('click', () => this.nextSong(false));
                this.miniNextBtn.dataset.bound = "true";
            }
        }

        bindUIEvents() {
            if (this.playBtn && !this.playBtn.dataset.bound) {
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.playBtn.dataset.bound = "true";
            }
            if (this.prevBtn && !this.prevBtn.dataset.bound) {
                this.prevBtn.addEventListener('click', () => this.prevSong());
                this.prevBtn.dataset.bound = "true";
            }
            if (this.nextBtn && !this.nextBtn.dataset.bound) {
                this.nextBtn.addEventListener('click', () => this.nextSong(false));
                this.nextBtn.dataset.bound = "true";
            }
            if (this.shuffleBtn && !this.shuffleBtn.dataset.bound) {
                this.shuffleBtn.addEventListener('click', () => this.toggleShuffle());
                this.shuffleBtn.dataset.bound = "true";
            }
            if (this.repeatBtn && !this.repeatBtn.dataset.bound) {
                this.repeatBtn.addEventListener('click', () => this.toggleRepeat());
                this.repeatBtn.dataset.bound = "true";
            }
            
            if (this.btnPlaylist && !this.btnPlaylist.dataset.bound) {
                this.btnPlaylist.addEventListener('click', () => this.switchView('playlist'));
                this.btnPlaylist.dataset.bound = "true";
            }
            if (this.btnLyrics && !this.btnLyrics.dataset.bound) {
                this.btnLyrics.addEventListener('click', () => this.switchView('lyrics'));
                this.btnLyrics.dataset.bound = "true";
            }
            
            // Progress Bar Dragging
            if(this.progressContainer && !this.progressContainer.dataset.bound) {
                const startProgressDrag = (e) => {
                    this.isDraggingProgress = true;
                    this.updateProgressFromEvent(e);

                    const onMouseMove = (moveEvent) => {
                         if (this.isDraggingProgress) {
                             moveEvent.preventDefault(); // Prevent text selection
                             this.updateProgressFromEvent(moveEvent);
                         }
                    };
                    
                    const onMouseUp = () => {
                        this.isDraggingProgress = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                this.progressContainer.addEventListener('mousedown', startProgressDrag);
                this.progressContainer.dataset.bound = "true";
            }
            
            // Volume Bar Dragging
             if(this.volumeControl && !this.volumeControl.dataset.bound) {
                const startVolumeDrag = (e) => {
                    this.isDraggingVolume = true;
                    this.updateVolumeFromEvent(e);
                    
                    const onMouseMove = (moveEvent) => {
                        if (this.isDraggingVolume) {
                             moveEvent.preventDefault();
                             this.updateVolumeFromEvent(moveEvent);
                        }
                    };
                    
                    const onMouseUp = () => {
                        this.isDraggingVolume = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                this.volumeControl.addEventListener('mousedown', startVolumeDrag);
                this.volumeControl.dataset.bound = "true";
             }
        }
        
        updateProgressFromEvent(e) {
             if(!this.progressContainer || !this.audio || !this.audio.duration) return;
             const rect = this.progressContainer.getBoundingClientRect();
             const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
             this.audio.currentTime = pos * this.audio.duration;
             if(this.progressBar) this.progressBar.style.width = `${pos * 100}%`;
             if(this.currentTimeEl) this.currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
        }

        updateVolumeFromEvent(e) {
            if(!this.volumeControl || !this.audio) return;
            const rect = this.volumeControl.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            this.audio.volume = pos;
            if(this.volumeBar) this.volumeBar.style.width = `${pos * 100}%`;
        }
        
        bindPlaylistEvents() {
            const playlistItems = document.querySelectorAll('.playlist-item');
            playlistItems.forEach(item => {
                item.addEventListener('click', () => {
                   const index = parseInt(item.dataset.index);
                   if(!isNaN(index)) {
                       this.loadSong(index, true);
                   }
                });
            });
        }

        async updatePlaylistDurations() {
             const items = document.querySelectorAll('.playlist-item .playlist-duration');
             this.playlist.forEach((song, index) => {
                if (items[index]) {
                    if (song.duration) {
                        items[index].textContent = song.duration;
                    } else if (song.url) {
                         // Optional: client side fetch
                    }
                }
             });
        }

        loadSong(index, autoPlay = true) {
            if(index < 0 || index >= this.playlist.length) return;
            
            this.currentIndex = index;
            const song = this.playlist[index];
            
            if (this.audio.src !== song.url && this.audio.src !== new URL(song.url, document.baseURI).href) {
                this.audio.src = song.url;
                this.lrcUrl = song.lrc || (song.url ? song.url.replace(/\.[^/.]+$/, ".lrc") : "");
                this.lyrics = []; // Clear lyrics
            }

            if(autoPlay) {
                this.audio.play().catch(e => console.error(e));
            } else {
                 if (this.isPlaying) this.audio.play(); 
            }
            
            this.updateUI();
            this.loadLyrics();
            
             if('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: song.title || 'Unknown Title',
                    artist: song.artist || 'Unknown Artist',
                    artwork: [{ src: song.cover || '/favicon.svg', sizes: '512x512', type: 'image/png' }]
                });
            }
        }
        
        togglePlay() {
            if (this.audio.paused) {
                this.audio.play();
            } else {
                this.audio.pause();
            }
        }
        
        prevSong() {
            let newIndex;
            if (this.isShuffle) {
                newIndex = Math.floor(Math.random() * this.playlist.length);
                 if (this.playlist.length > 1) {
                     while(newIndex === this.currentIndex) {
                         newIndex = Math.floor(Math.random() * this.playlist.length);
                     }
                }
            } else {
                newIndex = this.currentIndex - 1;
                if(newIndex < 0) {
                     // If loop is off, stop or wrap? Typically prev always wraps or goes to 0
                     newIndex = this.playlist.length - 1; 
                }
            }
            this.loadSong(newIndex, true);
        }
        
        nextSong(isAuto = false) {
             let newIndex;
            if (this.repeatMode === 'one' && isAuto) {
                 newIndex = this.currentIndex;
            } else if (this.isShuffle) {
                newIndex = Math.floor(Math.random() * this.playlist.length);
                 if (this.playlist.length > 1) {
                     while(newIndex === this.currentIndex) {
                         newIndex = Math.floor(Math.random() * this.playlist.length);
                     }
                }
            } else {
                newIndex = this.currentIndex + 1;
                if(newIndex >= this.playlist.length) {
                    if (this.repeatMode === 'off' && isAuto) {
                         // Stop playback if mode is off and end of list reached automatically
                         this.isPlaying = false;
                         this.updateUI();
                         return; 
                    }
                    newIndex = 0;
                }
            }
            this.loadSong(newIndex, true);
        }
        
        toggleShuffle() {
            // Toggle Shuffle
            this.isShuffle = !this.isShuffle;
            
            if (this.isShuffle) {
                // Shuffle ON: Visually disable repeat preference (technically internal logic handles skip)
                this.repeatMode = 'off';
            } else {
                // Shuffle OFF: Restore to default Sequence Loop
                this.repeatMode = 'all';
            }
            this.updateUI();
        }

        toggleRepeat() {
             if (this.isShuffle) {
                 // If dragging from Shuffle -> Turn off Shuffle, go to Sequence
                 this.isShuffle = false;
                 this.repeatMode = 'all'; 
             } else {
                 // Cycle Modes
                 if (this.repeatMode === 'all') {
                     this.repeatMode = 'one';
                 } else if (this.repeatMode === 'one') {
                     this.repeatMode = 'off';
                 } else {
                     this.repeatMode = 'all';
                 }
             }
             this.updateUI();
        }

        toggleMiniPlayer() {
             // Deprecated in favor of open/close hover
            if (!this.isMiniOpen) {
                this.openMiniPlayer();
            } else {
                this.closeMiniPlayer();
            }
        }

        closeMiniPlayer() {
            this.isMiniOpen = false;
            this.miniCard?.classList.add('opacity-0', 'scale-95', 'pointer-events-none');
            this.miniCard?.classList.remove('opacity-100', 'scale-100', 'pointer-events-auto');
            this.miniFab?.classList.remove('opacity-0', 'pointer-events-none', 'scale-0');
        }

        openMiniPlayer() {
            this.cancelCloseMiniPlayer();
            this.isMiniOpen = true;
            this.miniCard?.classList.remove('opacity-0', 'scale-95', 'pointer-events-none');
            this.miniCard?.classList.add('opacity-100', 'scale-100', 'pointer-events-auto');
            // Do NOT hide FAB completely on hover open, otherwise we can't click it!
            // But checking previous logic: hide if mini is open.
            // If user wants hover effect, FAB must remain visible to be hovered.
            // So we remove the "hide fab" logic.
            // this.miniFab?.classList.add('opacity-0', 'pointer-events-none', 'scale-0');
        }

        scheduleCloseMiniPlayer() {
            this.cancelCloseMiniPlayer();
            this.closeTimer = setTimeout(() => {
                this.closeMiniPlayer();
            }, 300);
        }

        cancelCloseMiniPlayer() {
            if (this.closeTimer) {
                clearTimeout(this.closeTimer);
                this.closeTimer = null;
            }
        }

        switchView(view) {
            if (view === 'playlist') {
                this.lyricsContainer?.classList.add('hidden');
                this.playlistContainer?.classList.remove('hidden');
                this.btnPlaylist?.classList.remove('text-neu-text-muted');
                this.btnPlaylist?.classList.add('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
                this.btnLyrics?.classList.add('text-neu-text-muted');
                this.btnLyrics?.classList.remove('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
            } else {
                this.lyricsContainer?.classList.remove('hidden');
                this.playlistContainer?.classList.add('hidden');
                this.btnLyrics?.classList.remove('text-neu-text-muted');
                this.btnLyrics?.classList.add('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
                this.btnPlaylist?.classList.add('text-neu-text-muted');
                this.btnPlaylist?.classList.remove('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
            }
        }
        
        updateUI() {
             const song = this.playlist[this.currentIndex];
             const coverSrc = song.cover || "";
             
             // --- Update Mini Player ---
             if (this.miniTitle) this.miniTitle.textContent = song.title || "Unknown Title";
             if (this.miniArtist) this.miniArtist.textContent = song.artist || "Unknown Artist";
             if (this.miniCover) this.miniCover.src = coverSrc;
             if (this.miniFabCover) this.miniFabCover.src = coverSrc;

             if (this.isPlaying) {
                 this.miniIconPlay?.classList.add('hidden');
                 this.miniIconPause?.classList.remove('hidden');
                 
                 this.miniFabIconPlay?.classList.add('hidden');
                 this.miniFabIconPause?.classList.remove('hidden');
                 
                 if (this.miniFabSpin) this.miniFabSpin.style.animationPlayState = 'running';
                  // Visualizer animation
                  if(this.visualizerBars) {
                      this.visualizerBars.forEach(bar => {
                          bar.classList.add('animate-pulse');
                          bar.style.height = Math.random() * 12 + 4 + 'px';
                      });
                  }
             } else {
                 this.miniIconPlay?.classList.remove('hidden');
                 this.miniIconPause?.classList.add('hidden');
                 
                 this.miniFabIconPlay?.classList.remove('hidden');
                 this.miniFabIconPause?.classList.add('hidden');

                 if (this.miniFabSpin) this.miniFabSpin.style.animationPlayState = 'paused';
                 if(this.visualizerBars) {
                      this.visualizerBars.forEach(bar => bar.classList.remove('animate-pulse'));
                  }
             }
             
             // --- Update Main Player (if exists) ---
            if (this.container) {
                // Text
                if(this.playerTitle) this.playerTitle.textContent = song.title || "Unknown Title";
                if(this.playerArtist) this.playerArtist.textContent = song.artist || "Unknown Artist";
                
                // Covers
                if(this.playerCover) this.playerCover.src = coverSrc;
                if(this.bgCover) this.bgCover.src = coverSrc;
                
                // Shuffle/Repeat State
                this.updateShuffleBtn();
                this.updateRepeatBtn();

                // Play/Pause State
                if (this.isPlaying) {
                    this.iconPlay?.classList.add('hidden');
                    this.iconPause?.classList.remove('hidden');
                    if (this.recordOuter) this.recordOuter.style.animationPlayState = 'running';
                    if (this.recordInner) this.recordInner.style.animationPlayState = 'running';
                    if (this.needle) this.needle.style.transform = 'rotate(30deg)';
                    if (this.statusDot) {
                        this.statusDot.classList.remove('bg-red-400');
                        this.statusDot.classList.add('bg-green-400');
                    }
                    if (this.statusText) this.statusText.textContent = '播放中';
                } else {
                    this.iconPlay?.classList.remove('hidden');
                    this.iconPause?.classList.add('hidden');
                    if (this.recordOuter) this.recordOuter.style.animationPlayState = 'paused';
                    if (this.recordInner) this.recordInner.style.animationPlayState = 'paused';
                    if (this.needle) this.needle.style.transform = 'rotate(0deg)';
                    if (this.statusDot) {
                        this.statusDot.classList.remove('bg-green-400');
                        this.statusDot.classList.add('bg-red-400');
                    }
                    if (this.statusText) this.statusText.textContent = '暂停';
                }
                
                // Update Active Playlist Item
                const items = document.querySelectorAll('.playlist-item');
                items.forEach((item, idx) => {
                    const iconDiv = item.querySelector('.absolute.inset-0.bg-black\\/10'); 
                    const title = item.querySelector('h3');
                    
                    if(idx === this.currentIndex) {
                        item.classList.add('active', 'border-neu-accent', 'bg-black/5', 'dark:bg-white/5');
                        item.classList.remove('border-transparent');
                        if(iconDiv) iconDiv.classList.remove('opacity-0');
                        if(title) title.classList.add('text-neu-accent');
                    } else {
                        item.classList.remove('active', 'border-neu-accent', 'bg-black/5', 'dark:bg-white/5');
                        item.classList.add('border-transparent');
                        if(iconDiv) iconDiv.classList.add('opacity-0');
                        if(title) title.classList.remove('text-neu-accent');
                    }
                });
            }
        }
        
         updateShuffleBtn() {
            if (this.shuffleBtn) {
                if (this.isShuffle) {
                    this.shuffleBtn.style.color = 'oklch(var(--p))';
                    this.shuffleBtn.classList.remove('text-neu-text-muted');
                } else {
                    this.shuffleBtn.style.color = '';
                    this.shuffleBtn.classList.add('text-neu-text-muted');
                }
            }
        }
        
        updateRepeatBtn() {
             if (this.repeatBtn) {
                // Highlight if 'all' or 'one'
                if (this.repeatMode === 'all' || this.repeatMode === 'one') {
                     this.repeatBtn.style.color = 'oklch(var(--p))';
                     this.repeatBtn.classList.remove('text-neu-text-muted');
                } else {
                     this.repeatBtn.style.color = '';
                     this.repeatBtn.classList.add('text-neu-text-muted');
                }
                
                // Optional: We could try to show visual distinction for 'one'
                // But without icon changing support, highlighting is the primary request.
            }
        }

        updateProgress() {
            if(!this.audio) return;
            // Stop updating UI if user is dragging progress bar
            if(this.isDraggingProgress) return;
            
            const { currentTime, duration } = this.audio;
            // Only update if UI exists
            if(this.currentTimeEl) this.currentTimeEl.textContent = this.formatTime(currentTime);
            if(this.totalTimeEl && duration) this.totalTimeEl.textContent = this.formatTime(duration);
            
            if(this.progressBar && duration) {
                const percent = (currentTime / duration) * 100;
                this.progressBar.style.width = `${percent}%`;
            }

            this.syncLyrics(currentTime);
            
             // Visualizer animation
             if(this.isPlaying && this.visualizerBars) {
                  this.visualizerBars.forEach(bar => {
                      bar.style.height = (Math.random() * 8 + 4) + 'px';
                  });
              }
        }
        
        formatTime(seconds) {
            if (isNaN(seconds)) return "0:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }
        
        async loadLyrics() {
             try {
                if(!this.lrcUrl) return;
                const response = await fetch(this.lrcUrl);
                if (response.ok) {
                    const text = await response.text();
                    this.lyrics = this.parseLyrics(text);
                    this.renderLyrics();
                } else {
                     if(this.lyricsContainer) this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">Lyrics fetch failed</p>';
                }
            } catch (e) {
                // console.error("Lyrics load failed", e);
                 if(this.lyricsContainer) this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">No lyrics available</p>';
            }
        }
        
        parseLyrics(lrcText) {
            const lines = lrcText.split('\n');
            const result = [];
            const timeReg = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
            
            for (const line of lines) {
                const cleanLine = line.trim();
                const match = timeReg.exec(cleanLine);
                if (match) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    const ms = parseInt(match[3].padEnd(3, '0')); // Handle 2 or 3 digits
                    
                    const time = min * 60 + sec + ms / 1000;
                    const text = cleanLine.replace(timeReg, '').trim();
                    
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result;
        }

        renderLyrics() {
            if (!this.lyricsContainer) return;
            
            const html = this.lyrics.map((line, index) => {
                return `<p class="lyric-line transition-all duration-500 py-1 text-neu-text-muted hover:text-neu-text cursor-pointer text-sm font-medium tracking-wide" data-time="${line.time}" data-index="${index}">${line.text}</p>`;
            }).join('');
            
            this.lyricsContainer.innerHTML = `<div class="py-[50%] flex flex-col items-center w-full space-y-4">${html}</div>`; 
            
            const lines = this.lyricsContainer.querySelectorAll('.lyric-line');
            lines.forEach(line => {
                line.addEventListener('click', () => {
                   const time = parseFloat(line.getAttribute('data-time'));
                   if(this.audio) {
                       this.audio.currentTime = time;
                       if (this.audio.paused) this.togglePlay();
                   }
                });
            });
        }
        
        syncLyrics(currentTime) {
             if (!this.lyrics.length || !this.lyricsContainer) return;
            
            // Find current line
            let activeIndex = -1;
            for (let i = 0; i < this.lyrics.length; i++) {
                if (currentTime >= this.lyrics[i].time) {
                    activeIndex = i;
                } else {
                    break;
                }
            }
            
            if (activeIndex !== -1 && activeIndex !== this.lastActiveIndex) {
                 this.lastActiveIndex = activeIndex;

                const lines = this.lyricsContainer.querySelectorAll('.lyric-line');
                
                lines.forEach((line, idx) => {
                    if (idx !== activeIndex) {
                         line.className = 'lyric-line transition-all duration-500 py-1 text-neu-text-muted hover:text-neu-text cursor-pointer text-sm font-medium tracking-wide';
                    }
                });
                
                const activeLine = lines[activeIndex];
                if (activeLine) {
                    activeLine.className = 'lyric-line transition-all duration-500 py-1 cursor-pointer text-base font-bold tracking-wider lyric-active';
                    
                    // Manual scroll calculation to prevent whole page scrolling
                    const containerHeight = this.lyricsContainer.clientHeight;
                    const lineTop = activeLine.offsetTop;
                    const lineHeight = activeLine.clientHeight;
                    
                    // Calculate center position
                    const scrollTarget = lineTop - (containerHeight / 2) + (lineHeight / 2);

                    this.lyricsContainer.scrollTo({
                        top: scrollTarget,
                        behavior: 'smooth'
                    });
                }
            }
        }
    }
    
    // Initialize Singleton
    if (!window.globalMusicPlayer) {
        window.globalMusicPlayer = new GlobalMusicPlayer();
    } else {
        // HMR Support: When file changes, we need to update the methods of the existing instance
        // or replace the instance while preserving state.
        const oldInstance = window.globalMusicPlayer;
        const newInstance = new GlobalMusicPlayer();
        
        // Preserve State
        newInstance.playlist = oldInstance.playlist;
        newInstance.currentIndex = oldInstance.currentIndex;
        newInstance.isPlaying = oldInstance.isPlaying;
        newInstance.isShuffle = oldInstance.isShuffle;
        newInstance.repeatMode = oldInstance.repeatMode;
        newInstance.lyrics = oldInstance.lyrics;
        newInstance.lrcUrl = oldInstance.lrcUrl;
        newInstance.audio = oldInstance.audio;
        newInstance.isMiniOpen = oldInstance.isMiniOpen;
        
        // cleanup old events/timers if necessary
        if(oldInstance.closeTimer) clearTimeout(oldInstance.closeTimer);
        
        // Replace
        window.globalMusicPlayer = newInstance;
        window.globalMusicPlayer.handlePageLoad();
    }
</script>
